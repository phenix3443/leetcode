# -*- coding:utf-8; -*-
"""
解题思路：
1. 题目分解为求单个水洼的面积。

观察每个水洼：
1. 每个水洼都偶有一个最低点的柱子B（Bottom）
2. B左侧柱子高度单调递增直到L，B右侧柱子高度单调递增直到R。（ *单调性* ）
3. 水洼的最大宽度与B左右两侧单调递增的最后一根柱子L和R有关。（ *边界问题* ）所以只需要遍历L-R之间的柱子，就能求得水洼面积。
4. 根据单调性和边界问题，可以想到单调栈，那么就要分析单调栈栈顶元素出栈操作和水洼面积的关系。为什么是考虑栈顶元素出栈？因为单调栈主要性质体现在栈顶元素出栈的过程中，而且根据图形可以明显看出，这是一个单调递减栈。

以第二个水洼为例进行分析，：
1. 首先根据线上的分析，这个水洼的左右边界分别是H[3]和H[7]。后续对这个结论进行验证。
2. 栈顶元素H[5]。
   + 因为它是水洼的最低点，所以肯定是计算这个水洼面积过程中最初单调栈的栈顶元素。所以首先研究这个元素出栈过程，和水池面积之间的关系。
   + 左侧H[4]和右侧H[6]，对H[5]夹逼，构成了水洼的一部分。而H[4]正好是栈顶第二的元素，H[6]是将要入栈的元素。H[5]出栈过程就是计算H[4]和H[6]夹逼H[5]形成的水洼面积的过程。累计该水洼面积，便在图中做涂黑，表示这部分水池面积已经无用。
   + H[5]出栈后，H[6]入栈。
2. 栈顶元素变为H[6]，待入栈的是H[7]。那么就应该看H[4]（栈顶第二元素）和H[7]夹逼H[6]形成的水洼面积。
   + 发现因为H[4],H[6]等高，所以没法形成水洼。
   + H[6]出栈，此时栈顶元素H[4]，H[4]<H[7]，同理继续分析H[3]和H[7]夹逼H[4]形成的水洼面积。可以发现正好是这个水洼剩余的部分。
3. H[4]出栈，此时栈顶元素是H[3]，但是此时单调栈空，说明H[3]左侧没有比它高的柱子可以和H[7]夹逼H[3]形成水洼。
4. 到此，和分析完成H[3]到H[7]之间的柱子，这部分水洼面积也计算完成，符合第一步验证。

"""


class Solution:
    def trap(self, heights):
        totalArea = 0
        stack = []
        for i in range(len(heights)):
            while stack and heights[stack[-1]] < heights[i]:
                idx = stack.pop()
                if not stack:  # 左边没有比栈顶元素高的柱子
                    break

                h = heights[idx]  # 当前柱子的高度
                l = stack[-1]  # 左侧第一个比当前柱子高的柱子

                areaH = min(heights[l], heights[i]) - h  # 夹逼高度
                areaW = i - l - 1  # 夹逼宽度
                area = areaH * areaW  # 当前柱子被左右两边柱子夹逼形成的水洼面积。
                # print(idx, areaH, areaW, area)
                totalArea += area

            stack.append(i)

        return totalArea


if __name__ == "__main__":
    heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]
    s = Solution()
    print(s.trap(heights))
